You are a senior full-stack engineer. Build a production-ready FM Radio Web App using only free and open-source tools and public APIs. Deliver clean, typed code, great UX, and thorough docs.

0) High-level goal

Create a mobile-first web app where users can:

Browse and search radio stations (initial focus: Bangladesh and India).

Play live streams with a reliable HTML5 player.

Filter by country, language, and tags/genres.

Save favourites locally.

Install as a PWA and control playback from the lock screen (Media Session API).

1) Tech stack (all free & OSS)

Frontend: Next.js 14+ (App Router) + TypeScript + Tailwind CSS
(If you must choose a bundler-only setup, use Vite + React + TS with identical UX.)

Audio: Native <audio> element. Optional: lightweight wrapper for events, but no paid libs.

Data/API: Radio Browser API (public, community-maintained directory of stations).
Base URL examples (use one of their mirrors):

/json/stations/bycountry/{CountryName}

/json/stations/search?name={q}

/json/stations/topclick/{n}

/json/languages / /json/tags
Use url_resolved for the final stream URL.

State: React state + localStorage (favourites & last played).

PWA: Web App Manifest + Service Worker (workbox or lightweight custom).

CI/CD: GitHub Actions; deploy to Vercel (free tier).

Important: Do not rely on any paid API or SaaS. Do not proxy the actual audio stream through serverless (Vercel) to avoid long-lived connection issues; stream directly in the browser.

2) Core features & UX

Home view

Country tabs: Bangladesh and India (default to Bangladesh for first load).

Search box (debounced) for station name; optional advanced filters (language, tags).

Sort controls: popularity (clicks), bitrate, recent change.

Station card list (logo, name, country flag, tags, bitrate). Skeleton loaders while fetching.

Play button on each card.

Now Playing bar

Persistent bottom mini-player: title, station name, play/pause, volume, seek (if applicable), mute.

Media Session API support for play/pause + metadata (station name, artwork if available).

“Open Full Player” to show a full-screen player with larger artwork and related stations.

Favourites

Heart icon toggle on station card.

Persist favourites in localStorage with a simple schema.

Details drawer

Station details: name, country, language, tags, bitrate, codec, homepage, favicon.

“Try mirrors / fallback URLs” button if playback fails.

Error handling & resilience

If a stream fails to load or stalls:

Retry once after a short delay.

Offer to try url vs url_resolved if both exist.

Show a friendly toast explaining that some stations may be temporarily offline.

Display placeholders for missing logos.

Internationalization (lightweight)

English UI text; make copy concise and clear.

Keep strings in a separate config for easy future i18n.

Accessibility & performance

Keyboard navigable.

Proper aria-* on player controls.

Lazy-load images; optimize for Core Web Vitals.

3) Data requirements

Use Radio Browser API to fetch:

Bangladesh stations: /json/stations/bycountry/Bangladesh

India stations: /json/stations/bycountry/India

For search: /json/stations/search?name={q} (scope to selected country when possible).

Use fields (handle missing):
stationuuid, name, country, language, tags, favicon, url, url_resolved, codec, bitrate, homepage.

Client-side fetch is acceptable for listing; do not proxy audio.
If CORS blocks listing endpoints, add a tiny Next.js Route Handler (/api/stations) that performs server-side fetch and returns JSON (short-lived, not streaming).

4) App architecture & folders
/app
  /(routes)
    /bd            -> Bangladesh station list
    /in            -> India station list
    /search        -> Global search (with country filter)
    /favorites     -> Favourites
  /api
    /stations/route.ts   -> Server-side fetch passthrough (if needed for CORS)
  /components
    StationCard.tsx
    StationList.tsx
    PlayerBar.tsx
    FullPlayer.tsx
    CountryTabs.tsx
    Filters.tsx
    EmptyState.tsx
    Skeleton.tsx
  /lib
    radioApi.ts           -> typed fetchers + mirror selection + error mapping
    types.ts              -> Station, ApiResponse, Favourites schema
    storage.ts            -> localStorage helpers
    mediaSession.ts       -> setup/teardown Media Session metadata & handlers
  /styles
    globals.css
/public
  icons, manifest.json, fallback-favicon.png
/service-worker.ts

5) TypeScript interfaces
export interface Station {
  stationuuid: string;
  name: string;
  country: string;
  language?: string;
  tags?: string;
  favicon?: string;
  url?: string;
  url_resolved?: string;
  codec?: string;
  bitrate?: number;
  homepage?: string;
}
export type CountryCode = "Bangladesh" | "India";

6) Player logic (must-haves)

Use a single <audio> element at app root, controlled via context.

On “Play”, set src = station.url_resolved || station.url, call play().

Listen for error, stalled, waiting, ended. On error:

Retry once after 1–2 seconds.

If still failing, surface fallback action (“Try alternative URL / mirrors”).

Update Media Session:

navigator.mediaSession.metadata = new MediaMetadata({
  title: station.name,
  artist: station.country,
  artwork: [{ src: station.favicon || "/fallback-favicon.png", sizes: "96x96", type: "image/png" }]
});

7) Filters & search

Country tabs: BD / IN.

Text search: Debounced 300ms, min 2 chars.

Advanced filters (optional): language dropdown (from /json/languages), tag chips (from /json/tags).

Sorting: by popularity (default), bitrate, name.

8) Favourites (local only)

Schema: favourites:v1 → array of { stationuuid, name, favicon, url_resolved }.

Provide a favourites page with remove/clear actions.

9) PWA requirements

Add manifest.json (name, short_name, icons, theme_color, display standalone).

Register service-worker.

Cache static assets and API list responses (stale-while-revalidate).

Do not cache/serve live audio streams offline.

Show “Install” prompt CTA where supported.

10) UI/UX details

Tailwind + clean, minimal design; dark/light mode toggle.

Responsive grid for cards; 3-line clamp on titles; hover states.

Toasts for errors and actions (e.g., “Added to favourites”).

Loading skeletons for list; empty-state illustrations for no results.

Country flags beside the tab labels.

Safe fonts (system stack).

11) Robustness & edge cases

Missing favicon → use fallback image.

Some streams use non-MP3 codecs; let the browser attempt playback; show a helpful error if unsupported.

Autoplay restrictions: user must click Play; provide a big primary Play CTA.

HLS streams: if encountered and native support is absent, skip advanced libs—keep to native audio only.

12) Testing & quality

Unit tests (Vitest or Jest) for:

radioApi fetchers (mock responses, error mapping).

storage helpers.

player context (play/pause state transitions).

E2E smoke tests (Playwright):

Load BD list → play first station → pause → add/remove favourite.

Lint/format: ESLint + Prettier + TypeScript strict.

Accessibility checks (axe) in CI.

13) Security & privacy

No tracking or analytics by default.

No cookies; only localStorage for favourites.

Respect CORS; do not proxy audio; if you add /api/stations, forward only short JSON queries.

14) Documentation

README.md with:

Features, screenshots, lighthouse scores.

How to run locally, build, and deploy to Vercel.

Known limitations (streams may go offline; some stations block cross-origin).

ENV: none required. If you add API route mirrors, make mirrors configurable via env but provide sensible defaults.

15) Acceptance criteria (must all pass)

✅ Landing page loads with Bangladesh tab active and shows station cards from Radio Browser.

✅ Switching to India tab fetches Indian stations.

✅ Searching for a term filters stations and updates results within 1s.

✅ Clicking Play starts audio, updates the Now Playing bar, and sets Media Session metadata.

✅ Favourites persist across reloads.

✅ App is installable as a PWA; works well on mobile; no console errors.

✅ No paid services or vendor-locked libraries used.

16) Deliverables

Complete Next.js + TS project in a single repo.

Deployed preview URL (Vercel).

README with setup, deployment, and troubleshooting.

Screenshots (mobile + desktop).

Minimal test coverage and passing CI.

Implement everything above. Where ambiguity exists, choose sensible defaults and proceed without asking for confirmation. Keep code clean, typed, and production-ready.